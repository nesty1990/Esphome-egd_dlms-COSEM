esphome:
  name: meter-dlms-rs485-2
  friendly_name: Meter DLMS RS485

esp32:
  board: esp32-s3-devkitc-1 
  framework:
    type: arduino

logger:
  level: DEBUG
  logs:
    light: ERROR

api:
ota:
  - platform: esphome
web_server:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: NONE
  reboot_timeout: 5min


# ---------- UART / RS-485 ----------
uart:
  id: rs485
  rx_pin: 
    number: GPIO1 
    inverted: false
  tx_pin: 
    number: GPIO2 
    inverted: false
  baud_rate: 9600
  parity: NONE
  stop_bits: 1
  rx_buffer_size: 512
  debug:
    direction: RX
    dummy_receiver: false

# ---------- DIODA ----------

light:
  - platform: neopixelbus
    id: onboard_led
    name: "Onboard RGB"
    pin: GPIO35
    num_leds: 1
    variant: SK6812
    type: GRB                
    default_transition_length: 0s
    restore_mode: ALWAYS_OFF
    internal: True

switch:
  - platform: template
    id: keepalive_led_enable
    name: "Powerbank Keepalive LED"
    optimistic: true
    restore_mode: "RESTORE_DEFAULT_ON"

# ---------- DLMS parser ----------
globals:
  - id: dlms_buf
    type: std::vector<uint8_t>
  - id: last_rx_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: last_frame_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: parse_index
    type: int
    initial_value: '0'
  - id: is_parsing
    type: bool
    initial_value: 'false'
  - id: frame_valid
    type: bool
    initial_value: 'false'
  - id: led_pulse_high
    type: bool
    initial_value: 'false'

interval:
  - interval: 50ms
    then:
      - lambda: |-
          // ---------------------------------------------------------
          // 1. INPUT HANDLING (Always runs to prevent overflow)
          // ---------------------------------------------------------
          while (id(rs485).available()) {
            uint8_t b;
            if (id(rs485).read_byte(&b)) {
              id(dlms_buf).push_back(b);
              id(last_rx_ms) = millis();
            } else {
              break;
            }
          }

          auto &buf = id(dlms_buf);

          // ---------------------------------------------------------
          // 2. STATE MANAGEMENT (Start/Stop decision)
          // ---------------------------------------------------------
          // If we aren't parsing, check if we should start
          if (!id(is_parsing)) {
            if (buf.empty()) return;
            // Wait for 500ms silence to ensure packet is complete
            if (millis() - id(last_rx_ms) <= 500) return; 

            // Initialize Parsing
            id(is_parsing) = true;
            id(frame_valid) = false;
            id(parse_index) = 0;
            
            // Handle header offset immediately
            if (buf[0] == 0x0F) {
              id(parse_index) = 12;
            }
          }

          // ---------------------------------------------------------
          // 3. PARSING LOOP (Time-Sliced)
          // ---------------------------------------------------------
          // Capture start time of this execution slice
          uint32_t start_slice = millis();

          // Define the matcher helper
          auto match_obis = [](const uint8_t* ln, uint8_t A,uint8_t B,uint8_t C,uint8_t D,uint8_t E,uint8_t F){
             return ln[0]==A && ln[1]==B && ln[2]==C && ln[3]==D && ln[4]==E && ln[5]==F;
          };

          // Resume where we left off (using global parse_index)
          while (id(parse_index) + 12 <= buf.size()) {
            
            // --- TIME GUARD: If we have worked for > 15ms, STOP and yield to ESPHome ---
            if (millis() - start_slice > 15) {
               return; // We will continue from id(parse_index) in the next 50ms cycle
            }

            int i = id(parse_index); // Local alias for readability

            // Check struct validity
            if (!(buf[i]==0x02 && buf[i+1]==0x02)) { 
                id(parse_index)++; 
                continue; 
            }

            uint16_t class_id = (uint16_t(buf[i+2])<<8) | buf[i+3];
            const uint8_t* ln  = &buf[i+4];
            uint8_t attr       = buf[i+10];
            uint8_t tag        = buf[i+11];
            
            // Advance the global index past the header
            id(parse_index) += 12; 
            i = id(parse_index); // Update local i to point to value

            // ---- Register values (class=3, attr=2) ----
            if (class_id==0x0003 && attr==0x02 && tag==0x06 && i+4 <= buf.size()) {
              uint32_t u = (uint32_t(buf[i])<<24)|(uint32_t(buf[i+1])<<16)|(uint32_t(buf[i+2])<<8)|buf[i+3];
              id(parse_index) += 4;

              bool matched = true;
              if      (match_obis(ln,1,0,1,7,0,255))  id(p_total_w).publish_state((float)u);
              else if (match_obis(ln,1,0,21,7,0,255)) id(p_l1_w).publish_state((float)u);
              else if (match_obis(ln,1,0,41,7,0,255)) id(p_l2_w).publish_state((float)u);
              else if (match_obis(ln,1,0,61,7,0,255)) id(p_l3_w).publish_state((float)u);
              else if (match_obis(ln,1,0,2,7,0,255))  id(pe_total_w).publish_state((float)u);
              else if (match_obis(ln,1,0,22,7,0,255)) id(pe_l1_w).publish_state((float)u);
              else if (match_obis(ln,1,0,42,7,0,255)) id(pe_l2_w).publish_state((float)u);
              else if (match_obis(ln,1,0,62,7,0,255)) id(pe_l3_w).publish_state((float)u);
              else if (match_obis(ln,1,0,1,8,0,255))  id(e_import_kwh).publish_state((float)u / 1000.0f);
              else if (match_obis(ln,1,0,2,8,0,255))  id(e_export_kwh).publish_state((float)u / 1000.0f);
              else if (match_obis(ln,1,0,1,8,1,255))  id(e_imp_t1_kwh).publish_state((float)u / 1000.0f);
              else if (match_obis(ln,1,0,1,8,2,255))  id(e_imp_t2_kwh).publish_state((float)u / 1000.0f);
              else if (match_obis(ln,1,0,1,8,3,255))  id(e_imp_t3_kwh).publish_state((float)u / 1000.0f);
              else if (match_obis(ln,1,0,1,8,4,255))  id(e_imp_t4_kwh).publish_state((float)u / 1000.0f);
              else matched = false;

              if(matched) id(frame_valid) = true;
              continue;
            }

            // ---- Power limiter register (class=71, attr=3) ----
            else if (class_id==0x0047 && attr==0x03 && tag==0x06 && i+4 <= buf.size()) {
              uint32_t u = (uint32_t(buf[i])<<24)|(uint32_t(buf[i+1])<<16)|(uint32_t(buf[i+2])<<8)|buf[i+3];
              if (match_obis(ln,0,0,17,0,0,255)) { id(p_lim).publish_state((float)u); id(frame_valid)=true; }
              id(parse_index) += 4;
              continue;
            }

            // ---- Disconnect / relay status (class=70, attr=3, enum) ----
            else if (class_id==0x0046 && attr==0x03 && tag==0x16 && i+1 <= buf.size()) {
              uint8_t v = buf[i];
              id(parse_index) += 1;
              
              bool matched = true;
              if (match_obis(ln,0,0,96,3,10,255)) id(disconnect_state).publish_state(v == 1);
              else if (match_obis(ln,0,1,96,3,10,255)) id(relay1state).publish_state(v == 1);
              else if (match_obis(ln,0,2,96,3,10,255)) id(relay2state).publish_state(v == 1);
              else if (match_obis(ln,0,3,96,3,10,255)) id(relay3state).publish_state(v == 1);
              else if (match_obis(ln,0,4,96,3,10,255)) id(relay4state).publish_state(v == 1);
              else if (match_obis(ln,0,5,96,3,10,255)) id(relay5state).publish_state(v == 1);
              else if (match_obis(ln,0,6,96,3,10,255)) id(relay6state).publish_state(v == 1);
              else matched = false;

              if(matched) id(frame_valid) = true;
              continue;
            }

            // ---- String values (class=1, attr=2, octet-string) ----
            else if (class_id==0x0001 && attr==0x02 && tag==0x09 && i+1 <= buf.size()) {
              uint8_t L = buf[i];
              // Ensure we have the full string in buffer
              if (i + 1 + L > buf.size()) break; 
              
              // Increment past length byte
              id(parse_index) += 1; 

              bool matched = true;
              if      (match_obis(ln,0,0,96,1,0,255))  id(serial).publish_state(std::string((char*)&buf[i+1], L));
              else if (match_obis(ln,0,0,96,14,0,255)) id(tariff).publish_state(std::string((char*)&buf[i+1], L));
              else if (match_obis(ln,0,0,42,0,0,255))  id(device_name).publish_state(std::string((char*)&buf[i+1], L));
              else if (match_obis(ln,0,0,96,13,0,255)) id(consumer_message).publish_state(std::string((char*)&buf[i+1], L));
              else matched = false;

              if(matched) id(frame_valid) = true;
              id(parse_index) += L;
              continue;
            }

            // ---- Skip unknown types safely ----
            else if (tag==0x06 && i+4 <= buf.size()) id(parse_index) += 4;
            else if (tag==0x16 && i+1 <= buf.size()) id(parse_index) += 1;
            else if (tag==0x09 && i+1 <= buf.size()) { 
               uint8_t L = buf[i]; 
               id(parse_index) += (1 + L); 
            }
          }

          // ---------------------------------------------------------
          // 4. CLEANUP (Only reached when buffer exhausted)
          // ---------------------------------------------------------
          if (id(frame_valid)) {
             id(last_frame_ok).publish_state(true);
             id(last_frame_ms) = millis();
          }
          
          buf.clear();
          id(is_parsing) = false;
          id(parse_index) = 0;

  - interval: 1s
    then:
      # 1. Toggle the pulse state (High <-> Low)
      - globals.set:
          id: led_pulse_high
          value: !lambda 'return !id(led_pulse_high);'

      # 2. Check Logic Hierarchy (Red -> Yellow -> Green)
      - if:
          condition:
            not:
              wifi.connected:
          then:
            # Case 1: WiFi Disconnected -> RED
            - light.turn_on:
                id: onboard_led
                red: 1.0
                green: 0.0
                blue: 0.0
                # Use lambda to switch brightness based on the global
                brightness: !lambda 'return id(led_pulse_high) ? 1.0 : 0.3;'
                transition_length: 800ms # Smooth fading between steps

          else:
            - if:
                condition:
                  binary_sensor.is_on: meter_online
                then:
                  # Case 3: Everything OK -> GREEN
                  - light.turn_on:
                      id: onboard_led
                      red: 0.0
                      green: 1.0
                      blue: 0.0
                      brightness: !lambda 'return id(led_pulse_high) ? 1.0 : 0.3;'
                      transition_length: 800ms
                else:
                  # Case 2: Meter Offline -> YELLOW
                  - light.turn_on:
                      id: onboard_led
                      red: 1.0
                      green: 1.0
                      blue: 0.0
                      brightness: !lambda 'return id(led_pulse_high) ? 1.0 : 0.3;'
                      transition_length: 800ms

# ---------- Sensors exposed to Home Assistant ----------
sensor:
  - platform: template
    id: p_total_w
    name: "Total Active Power"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    state_class: measurement

  - platform: template
    id: p_l1_w
    name: "Power L1"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    state_class: measurement

  - platform: template
    id: p_l2_w
    name: "Power L2"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    state_class: measurement

  - platform: template
    id: p_l3_w
    name: "Power L3"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    state_class: measurement

  - platform: template
    id: pe_total_w
    name: "Total Power Export"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    state_class: measurement

  - platform: template
    id: pe_l1_w
    name: "Power Export L1"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    state_class: measurement

  - platform: template
    id: pe_l2_w
    name: "Power Export L2"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    state_class: measurement

  - platform: template
    id: pe_l3_w
    name: "Power Export L3"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    state_class: measurement

  - platform: template
    id: p_lim
    name: "Power Limiter"
    unit_of_measurement: "W"
    accuracy_decimals: 0
    device_class: power
    state_class: measurement

  - platform: template
    id: e_import_kwh
    name: "Total Energy Import"
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    device_class: energy
    state_class: total_increasing

  - platform: template
    id: e_export_kwh
    name: "Total Energy Export"
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    device_class: energy
    state_class: total_increasing

  - platform: template
    id: e_imp_t1_kwh
    name: "Energy T1"
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    device_class: energy
    state_class: total_increasing

  - platform: template
    id: e_imp_t2_kwh
    name: "Energy T2"
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    device_class: energy
    state_class: total_increasing

  - platform: template
    id: e_imp_t3_kwh
    name: "Energy T3"
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    device_class: energy
    state_class: total_increasing

  - platform: template
    id: e_imp_t4_kwh
    name: "Energy T4"
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    device_class: energy
    state_class: total_increasing

binary_sensor:

  - platform: template
    id: disconnect_state
    name: "Disconnect State"

  - platform: template
    id: relay1state
    name: "Relay 1"

  - platform: template
    id: relay2state
    name: "Relay 2"

  - platform: template
    id: relay3state
    name: "Relay 3"

  - platform: template
    id: relay4state
    name: "Relay 4"

  - platform: template
    id: relay5state
    name: "Relay 5"

  - platform: template
    id: relay6state
    name: "Relay 6"

  - platform: template
    id: last_frame_ok
    name: "Parsing OK"
    entity_category: diagnostic

  - platform: template
    id: meter_online
    name: "Meter Online"
    entity_category: diagnostic
    lambda: |-
      return (id(last_frame_ms) != 0) && (millis() - id(last_frame_ms) < 120000);  // 2 min

text_sensor:
  - platform: template
    id: tariff
    name: "Active Tariff"
  - platform: template
    id: serial
    name: "Device Serial"
  - platform: template
    id: device_name
    name: "Device Name"

  - platform: template
    id: consumer_message
    name: "Message"
    entity_category: "diagnostic"
    
  - platform: template
    name: "ESPHome Version"
    id: esphome_project_version_text_short
    icon: "mdi:information-box"
    entity_category: "diagnostic"
    update_interval: 600s
    lambda: |-
      return { ESPHOME_VERSION };

button:
  - platform: restart
    name: "ESP Restart"
    id: restart_button
    icon: "mdi:restart"

time:
  - platform: sntp
